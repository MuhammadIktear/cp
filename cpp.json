{
"cp": {
  "prefix": "cp",
  "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#define int long long",
    "#define ll long long",
    "#define vec vector<int>",
    "#define pii pair<int,int>",
    "#define mii map<int,int>",
    "#define vp vector<pair<int,int>>",
    "#define fast_io ios::sync_with_stdio(false); cin.tie(nullptr)",
    "#define py cout << \"YES\\n\"",
    "#define pn cout << \"NO\\n\"",
    "#define in(n) int n;cin>>n",
    "#define in2(a,b) int a,b;cin>>a>>b",
    "#define in3(a,b,c) int a,b,c;cin>>a>>b>>c",
    "#define pb(x) push_back(x)",
    "#define sortv(x) sort(x.begin(), x.end())",
    "#define sortr(x) sort(x.rbegin(), x.rend())",
    "#define loop(s,i,n) for(int i=s;i<n;i++)",
    "#define loopr(s,i,n) for(int i=n-1;i>=s;i--)",
    "#define loopa(u,x) for(auto u:x)",
    "#define F first",
    "#define S second",
    "#define endl '\\n'",
    "#define mem(a,b) memset(a, b, sizeof(a) )",
    "#define printv(a) {for(auto u:a) cout<<u<<\" \"; cout<<endl;}",
    "//debug",
    "template<typename F,typename S>ostream&operator<<(ostream&os,const pair<F,S>&p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}",
    "template<typename T>ostream&operator<<(ostream&os,const vector<T>&v){os<<\"{\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\", \";os<<*it;}return os<<\"}\";}",
    "template<typename T>ostream&operator<<(ostream&os,const set<T>&v){os<<\"[\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\",\";os<<*it;}return os<<\"]\";}",
    "template<typename T>ostream&operator<<(ostream&os,const multiset<T>&v) {os<<\"[\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\", \";os<<*it;}return os<<\"]\";}",
    "template<typename F,typename S>ostream&operator<<(ostream&os,const map<F,S>&v){os<<\"[\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\", \";os<<it->first<<\" = \"<<it->second;}return os<<\"]\";}",
    "#define dbg(args...) do {cerr << #args << \" : \"; faltu(args); } while(0)",
    "void faltu(){cerr << endl;}",
    "template<typename T>void faltu(T a[],int n){for(int i=0;i<n;++i)cerr<<a[i]<<' ';cerr<<endl;}",
    "template<typename T,typename...heinto>void faltu(T arg,const heinto&...rest){cerr<<arg<<' ';faltu(rest...);}",
    "//gcd,lcm",
    "int gcd ( int a, int b ) { return __gcd ( a, b ); }",
    "int lcm ( int a, int b ) { return a * ( b / gcd ( a, b ) ); } ",
    "// Input/output helpers",
    "template <typename T> void read(vector<T>& v) { for (auto& x : v) cin >> x; }",
    "template <typename T> void print(const vector<T>& v) { for (const auto& x : v) cout << x << ' '; cout << '\\n'; }",
    "",
    "//mod",
    "#define MOD 1000000007",
    "inline void normal(ll &a) { a %= MOD; (a < 0) && (a += MOD); }",
    "inline ll modMul(ll a, ll b) { a %= MOD, b %= MOD; normal(a), normal(b); return (a*b)%MOD; }",
    "inline ll modAdd(ll a, ll b) { a %= MOD, b %= MOD; normal(a), normal(b); return (a+b)%MOD; }",
    "inline ll modSub(ll a, ll b) { a %= MOD, b %= MOD; normal(a), normal(b); a -= b; normal(a); return a; }",
    "inline ll modPow(ll b, ll p) { ll r = 1; while(p) { if(p&1) r = modMul(r, b); b = modMul(b, b); p >>= 1; } return r; }",
    "",
    "const int mx = 1e5+123;",
    "",
    "void solve()",
    "{",
    "",
    "}",
    "",
    "int32_t main()",
    "{",
    "    fast_io;",
    "    int t = 1;",
    "    cin >> t;  ",
    "    while (t--) solve();",
    "    return 0;",
    "}"
  ],
  "description": "cp template"
},	
	"node": {
		"prefix": "node",
		"body": [
			"class Node",
			"{",
			" public:",
			"    int val;",
			"    Node *next;",
			"    Node(int val)",
			"    {",
			"        this->val=val;",
			"        this->next=NUint;",
			"    }",
			"};"
		],
		"description": ""
	},
	"Prime Generation Algorithm": {
		"prefix": "primeGen",
		"body": [
			"bitset<mx> isPrime;",
			"vector<int> primes;",
			"",
			"void primeGen(int n) {",
			"    for (int i = 3; i <= n; i += 2) isPrime[i] = 1;",
			"",
			"    int sq = sqrt(n);",
			"    for (int i = 3; i <= sq; i += 2) {",
			"        if (isPrime[i]) {",
			"            for (int j = i * i; j <= n; j += i) {",
			"                isPrime[j] = 0;",
			"            }",
			"        }",
			"    }",
			"",
			"    primes.push_back(2);",
			"    for (int i = 3; i <= n; i += 2) {",
			"        if (isPrime[i] == 1) {",
			"            primes.push_back(i);",
			"        }",
			"    }",
			"}"
		],
		"description": "Generate prime numbers up to n using the Sieve of Eratosthenes"
	  },
		"isPrime": {
			"prefix": "isPrime",
			"body": [
				"bool isPrime_(int n) {",
				"    if (n <= 1)",
				"        return false;",
				"    for (int i = 2; i * i <= n; i++) {",
				"        if (n % i == 0)",
				"            return false;",
				"    }",
				"    return true;",
				"}"
			],
			"description": "Checks if a number is prime"
		},
		  "numberOfDivisors": {
			  "prefix": "numberOfDivisors",
			  "body": [
				  "int numberOfDivisors(int n) {",
				  "    int ans = 1;",
				  "    for (auto u : primes) {",
				  "        if (1LL * u * u > n) break;",
				  "        if (n % u == 0) {",
				  "            int a = 0;",
				  "            while (n % u == 0) {",
				  "                a++;",
				  "                n /= u;",
				  "            }",
				  "            ans *= (a + 1);",
				  "        }",
				  "    }",
				  "    if (n != 1) {",
				  "        ans *= 2;",
				  "    }",
				  "    return ans;",
				  "}"
			  ],
			  "description": "Calculates the number of divisors of a given number using a list of primes"
		  }  ,
"stl": {
  "prefix": "stl",
  "body": [
    "// Data Structures",
    "void stl_containers_demo() {",
    "    // Vectors",
    "    vector<int> v = {1, 2, 3};",
    "    v.push_back(4);            // Add element at the end",
    "    v.pop_back();              // Remove last element",
    "    sort(v.begin(), v.end());  // Sort",
    "    reverse(v.begin(), v.end()); // Reverse",
    "    cout << v.front() << \" \" << v.back() << \"\\n\"; // Access first/last element",
    "",
    "    // Sets",
    "    set<int> s = {3, 1, 4};",
    "    s.insert(2);",
    "    s.erase(3);",
    "    cout << *s.begin() << \"\\n\"; // Smallest element",
    "",
    "    // Multiset (allows duplicates)",
    "    multiset<int> ms = {1, 1, 2};",
    "    ms.erase(ms.find(1)); // Erases one occurrence of 1",
    "",
    "    // Unordered Sets",
    "    unordered_set<int> us = {1, 2, 3};",
    "",
    "    // Maps",
    "    map<int, string> m;",
    "    m[1] = \"one\";",
    "    m[2] = \"two\";",
    "    for (auto& p : m) cout << p.first << \": \" << p.second << \"\\n\";",
    "",
    "    // Multimap",
    "    multimap<int, string> mm;",
    "    mm.insert({1, \"a\"});",
    "    mm.insert({1, \"b\"});",
    "",
    "    // Unordered Maps",
    "    unordered_map<string, int> um;",
    "    um[\"apple\"] = 10;",
    "",
    "    // Stacks",
    "    stack<int> st;",
    "    st.push(1);",
    "    st.push(2);",
    "    cout << st.top() << \"\\n\"; // Top element",
    "    st.pop();",
    "",
    "    // Queues",
    "    queue<int> q;",
    "    q.push(1);",
    "    q.push(2);",
    "    cout << q.front() << \"\\n\"; // First element",
    "    q.pop();",
    "",
    "    // Priority Queue (Max-Heap)",
    "    priority_queue<int> pq;",
    "    pq.push(3);",
    "    pq.push(1);",
    "    pq.push(2);",
    "    cout << pq.top() << \"\\n\"; // Largest element",
    "    pq.pop();",
    "",
    "    // Priority Queue (Min-Heap)",
    "    priority_queue<int, vector<int>, greater<int>> min_pq;",
    "    min_pq.push(3);",
    "    min_pq.push(1);",
    "    min_pq.push(2);",
    "    cout << min_pq.top() << \"\\n\"; // Smallest element",
    "}",
    "",
    "// Algorithms",
    "void stl_algorithms_demo() {",
    "    vector<int> v = {1, 2, 3, 4, 5};",
    "",
    "    // Searching",
    "    cout << binary_search(v.begin(), v.end(), 3) << \"\\n\"; // 1 (found)",
    "",
    "    // Min/Max",
    "    cout << *min_element(v.begin(), v.end()) << \"\\n\"; // 1",
    "    cout << *max_element(v.begin(), v.end()) << \"\\n\"; // 5",
    "",
    "    // Sum",
    "    cout << accumulate(v.begin(), v.end(), 0) << \"\\n\"; // 15",
    "",
    "    // Count occurrences",
    "    cout << count(v.begin(), v.end(), 3) << \"\\n\"; // 1",
    "",
    "    // Find element",
    "    auto it = find(v.begin(), v.end(), 4);",
    "    if (it != v.end()) cout << *it << \"\\n\";",
    "",
    "    // Remove duplicates",
    "    v = {1, 1, 2, 2, 3};",
    "    v.erase(unique(v.begin(), v.end()), v.end()); // {1, 2, 3}",
    "",
    "    // Permutations",
    "    sort(v.begin(), v.end());",
    "    do {",
    "        for (auto x : v) cout << x << \" \";",
    "        cout << \"\\n\";",
    "    } while (next_permutation(v.begin(), v.end()));",
    "}",
    "",
    "// String Operations",
    "void stl_string_demo() {",
    "    string s = \"Hello\";",
    "",
    "    // Append and insert",
    "    s.append(\" World\");",
    "    s.insert(5, \",\"); // s: \"Hello, World\"",
    "    cout << s << \"\\n\";",
    "",
    "    // Erase and replace",
    "    s.erase(5, 1);  // s: \"Hello World\"",
    "    s.replace(6, 5, \"Universe\");  // s: \"Hello Universe\"",
    "    cout << s << \"\\n\";",
    "",
    "    // Access",
    "    cout << s[0] << \" \" << s.at(6) << \"\\n\";  // Output: H U",
    "",
    "    // Find and substr",
    "    cout << s.find(\"Universe\") << \"\\n\";  // Output: 6",
    "    cout << s.substr(0, 5) << \"\\n\";      // Output: Hello",
    "",
    "    // Sort and reverse",
    "    sort(s.begin(), s.end());",
    "    cout << s << \"\\n\";  // Sorted",
    "    reverse(s.begin(), s.end());",
    "    cout << s << \"\\n\";  // Reversed",
    "",
    "    // Conversion",
    "    string num = \"123\";",
    "    int x = stoi(num);  // Convert to integer",
    "    cout << x + 1 << \"\\n\";  // 124",
    "    string back = to_string(x);",
    "    cout << back + \"0\" << \"\\n\"; // \"1230\"",
    "}",
    "",
    "// Utility Functions",
    "void stl_utilities_demo() {",
    "    // Pairs",
    "    // Pair",
    "    pair<int, string> p1 = {1, \"One\"};",
    "    pair<int, string> p2 = {2, \"Two\"};",
    "",
    "    // Pair operations",
    "    cout << p1.first << \" \" << p1.second << \"\\n\"; // 1 One",
    "    swap(p1, p2);",
    "    cout << p1.first << \" \" << p1.second << \"\\n\"; // 2 Two",
    "",
    "    // Nested pairs",
    "    pair<int, pair<int, string>> nested_p = {1, {2, \"Nested\"}};",
    "    cout << nested_p.first << \" \" << nested_p.second.first << \" \" << nested_p.second.second << \"\\n\";",
    "",
    "    // Map",
    "    map<int, string> m;",
    "    m[1] = \"One\";",
    "    m[2] = \"Two\";",
    "    m[3] = \"Three\";",
    "",
    "    // Iteration over map",
    "    for (auto& [key, value] : m) cout << key << \": \" << value << \"\\n\";",
    "",
    "    // Map operations",
    "    if (m.find(2) != m.end()) cout << \"Key 2 found with value: \" << m[2] << \"\\n\";",
    "    m.erase(2);  // Remove key 2",
    "    m[4] = \"Four\";",
    "",
    "    // Access with default value",
    "    cout << m[5] << \"\\n\"; // Creates key 5 with default value \"\"",
    "",
    "    // Lower and upper bounds in map",
    "    auto lb = m.lower_bound(3); // First element >= 3",
    "    auto ub = m.upper_bound(3); // First element > 3",
    "    if (lb != m.end()) cout << \"Lower bound: \" << lb->first << \"\\n\";",
    "    if (ub != m.end()) cout << \"Upper bound: \" << ub->first << \"\\n\";",
    "",
    "    // Unordered Map",
    "    unordered_map<string, int> um = {{\"apple\", 10}, {\"banana\", 20}};",
    "    for (auto& [key, value] : um) cout << key << \": \" << value << \"\\n\";",
    "",
    "    // Multimap",
    "    multimap<int, string> mm;",
    "    mm.insert({1, \"One\"});",
    "    mm.insert({1, \"Another One\"});",
    "    mm.insert({2, \"Two\"});",
    "    for (auto& [key, value] : mm) cout << key << \": \" << value << \"\\n\";",
    "",
    "    // Set",
    "    set<int> s = {3, 1, 4, 1, 2};",
    "    s.insert(5);",
    "    s.erase(3);",
    "    for (int x : s) cout << x << \" \"; // Sorted unique values: 1 2 4 5",
    "    cout << \"\\n\";",
    "",
    "    // Check presence in set",
    "    if (s.find(4) != s.end()) cout << \"4 found in set\\n\";",
    "",
    "    // Lower and upper bounds in set",
    "    auto s_lb = s.lower_bound(2);",
    "    auto s_ub = s.upper_bound(2);",
    "    if (s_lb != s.end()) cout << \"Set lower bound: \" << *s_lb << \"\\n\";",
    "    if (s_ub != s.end()) cout << \"Set upper bound: \" << *s_ub << \"\\n\";",
    "",
    "    // Multiset (allows duplicates)",
    "    multiset<int> ms = {1, 1, 2, 2, 3};",
    "    ms.insert(2);",
    "    cout << ms.count(2) << \"\\n\"; // Count occurrences of 2: 3",
    "",
    "    // Erase one occurrence in multiset",
    "    ms.erase(ms.find(2));",
    "    for (int x : ms) cout << x << \" \"; // 1 1 2 2 3",
    "    cout << \"\\n\";",
    "",
    "    // Unordered Set",
    "    unordered_set<int> us = {1, 2, 3, 4};",
    "    us.erase(3);",
    "    us.insert(5);",
    "    for (int x : us) cout << x << \" \"; // Unordered elements",
    "    cout << \"\\n\";",
    "",
    "    // Multimap range of equal keys",
    "    auto range = mm.equal_range(1);",
    "    for (auto it = range.first; it != range.second; ++it) {",
    "        cout << it->first << \": \" << it->second << \"\\n\";",
    "    }",
    "    // Tuples",
    "    tuple<int, string, double> t = {1, \"hello\", 3.14};",
    "    cout << get<1>(t) << \"\\n\"; // \"hello\"",
    "",
    "    // Lambda functions",
    "    auto add = [](int a, int b) { return a + b; };",
    "    cout << add(3, 4) << \"\\n\"; // 7",
    "}",
    ""
  ],
  "description": ""
}	,
"dp": {
  "prefix": "dp",
  "body": [
    "//knapsack recursive approach",
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "int knapsack(int n, int weight[], int value[], int W)",
    "",
    "{",
    "",
    " if (n == 0 || W == 0)",
    "",
    " return 0;",
    "",
    " if (weight[n - 1] <= W)",
    "",
    " {",
    "",
    " // duita option",
    "",
    " // niye dekhbo, na niye dekhbo",
    "",
    " int op1 = knapsack(n - 1, weight, value, W - weight[n - 1]) + value[n - 1];",
    "",
    " int op2 = knapsack(n - 1, weight, value, W);",
    "",
    " return max(op1, op2);",
    "",
    " }",
    "",
    " else",
    "",
    " {",
    "",
    " // ekta option",
    "",
    " // na niyei dekhte hobe",
    "",
    " int op2 = knapsack(n - 1, weight, value, W);",
    "",
    " return op2;",
    "",
    " }",
    "",
    "}",
    "",
    "int main()",
    "",
    "{",
    "",
    " int n;",
    "",
    " cin >> n;",
    "",
    " int weight[n], value[n];",
    "",
    " for (int i = 0; i < n; i++)",
    "",
    " {",
    "",
    " cin >> weight[i];",
    "",
    " }",
    "",
    " for (int i = 0; i < n; i++)",
    "",
    " {",
    "",
    " cin >> value[i];",
    "",
    " }",
    "",
    " int W;",
    "",
    " cin >> W;",
    "",
    " cout << knapsack(n, weight, value, W) << endl;",
    "",
    " return 0;",
    "",
    "}",
    "",
    "",
    "//subset sum top down",
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "int dp[1005][1005];",
    "",
    "bool subset_sum(int n, int a[], int s)",
    "",
    "{",
    "",
    " if (n == 0)",
    "",
    " {",
    "",
    " if (s == 0)",
    "",
    " return true;",
    "",
    " else",
    "",
    " return false;",
    "",
    " }",
    "",
    " if (dp[n][s] != -1)",
    "",
    " return dp[n][s];",
    "",
    " if (a[n - 1] <= s)",
    "",
    " {",
    "",
    " bool op1 = subset_sum(n - 1, a, s - a[n - 1]);",
    "",
    " bool op2 = subset_sum(n - 1, a, s);",
    "",
    " return dp[n][s] = op1 || op2;",
    "",
    " }",
    "",
    " else",
    "",
    " {",
    "",
    " return dp[n][s] = subset_sum(n - 1, a, s);",
    "",
    " }",
    "",
    "}",
    "",
    "int main()",
    "",
    "{",
    "",
    " int n;",
    "",
    " cin >> n;",
    "",
    " int a[n];",
    "",
    " for (int i = 0; i < n; i++)",
    "",
    " {",
    "",
    " cin >> a[i];",
    "",
    " }",
    "",
    " int s;",
    "",
    " cin >> s;",
    "",
    " for (int i = 0; i <= n; i++)",
    "",
    " {",
    "",
    " for (int j = 0; j <= s; j++)",
    "",
    " {",
    "",
    " dp[i][j] = -1;",
    "",
    " }",
    "",
    " }",
    "",
    " if (subset_sum(n, a, s))",
    "",
    " {",
    "",
    " cout << \"YES\" << endl;",
    "",
    " }",
    "",
    " else",
    "",
    " {",
    "",
    " cout << \"NO\" << endl;",
    "",
    " }",
    "",
    " return 0;",
    "",
    "}",
    "",
    "//count subset sum",
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "int dp[1005][1005];",
    "",
    "int subset_sum(int n, int a[], int s)",
    "",
    "{",
    "",
    " if (n == 0)",
    "",
    " {",
    "",
    " if (s == 0)",
    "",
    " return 1;",
    "",
    " else",
    "",
    " return 0;",
    "",
    " }",
    "",
    " if (dp[n][s] != -1)",
    "",
    " return dp[n][s];",
    "",
    " if (a[n - 1] <= s)",
    "",
    " {",
    "",
    " int op1 = subset_sum(n - 1, a, s - a[n - 1]);",
    "",
    " int op2 = subset_sum(n - 1, a, s);",
    "",
    " return dp[n][s] = op1 + op2;",
    "",
    " }",
    "",
    " else",
    "",
    " {",
    "",
    " return dp[n][s] = subset_sum(n - 1, a, s);",
    "",
    " }",
    "",
    "}",
    "",
    "int main()",
    "",
    "{",
    "",
    " int n;",
    "",
    " cin >> n;",
    "",
    " int a[n];",
    "",
    " for (int i = 0; i < n; i++)",
    "",
    " {",
    "",
    " cin >> a[i];",
    "",
    " }",
    "",
    " int s;",
    "",
    " cin >> s;",
    "",
    " dp[0][0] = true;",
    "",
    " for (int i = 1; i <= s; i++)",
    "",
    " {",
    "",
    " dp[0][i] = 0;",
    "",
    " }",
    "",
    " for (int i = 1; i <= n; i++)",
    "",
    " {",
    "",
    " for (int j = 0; j <= s; j++)",
    "",
    " {",
    "",
    " if (a[i - 1] <= j)",
    "",
    " {",
    "",
    " dp[i][j] = dp[i - 1][j - a[i - 1]] + dp[i - 1][j];",
    "",
    " }",
    "",
    " else",
    "",
    " {",
    "",
    " dp[i][j] = dp[i - 1][j];",
    "",
    " }",
    "",
    " }",
    "",
    " }",
    "",
    " for (int i = 0; i <= n; i++)",
    "",
    " {",
    "",
    " for (int j = 0; j <= s; j++)",
    "",
    " {",
    "",
    " cout << dp[i][j] << \" \";",
    "",
    " }",
    "",
    " cout << endl;",
    "",
    " }",
    "",
    " return 0;",
    "",
    "}",
    "//Equal sum partition",
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "int main()",
    "",
    "{",
    "",
    " int n;",
    "",
    " cin >> n;",
    "",
    " int s = 0;",
    "",
    " int a[n];",
    "",
    " for (int i = 0; i < n; i++)",
    "",
    " {",
    "",
    " cin >> a[i];",
    "",
    " s += a[i];",
    "",
    " }",
    "",
    " if (s % 2 == 0)",
    "",
    " {",
    "",
    " int sum = s / 2;",
    "",
    " bool dp[n + 1][sum + 1];",
    "",
    " dp[0][0] = true;",
    "",
    " for (int i = 1; i <= sum; i++)",
    "",
    " dp[0][i] = false;",
    "",
    " for (int i = 1; i <= n; i++)",
    "",
    " {",
    "",
    " for (int j = 0; j <= sum; j++)",
    "",
    " {",
    "",
    " if (a[i - 1] <= j)",
    "",
    " {",
    "",
    " dp[i][j] = dp[i - 1][j - a[i - 1]] || dp[i - 1][j];",
    "",
    " }",
    "",
    " else",
    "",
    " {",
    "",
    " dp[i][j] = dp[i - 1][j];",
    "",
    " }",
    "",
    " }",
    "",
    " }",
    "",
    " if (dp[n][sum])",
    "",
    " cout << \"YES\" << endl;",
    "",
    " else",
    "",
    " cout << \"NO\" << endl;",
    "",
    " }",
    "",
    " else",
    "",
    " {",
    "",
    " cout << \"NO\" << endl;",
    "",
    " }",
    "",
    " return 0;",
    "",
    "}",
    "",
    "//coin change 1",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "int main()",
    "{",
    "    int n;",
    "    cin >> n;",
    "    int w[n];",
    "    for (int i = 0; i < n; i++)",
    "    {",
    "        cin >> w[i];",
    "    }",
    "    int s;",
    "    cin >> s;",
    "    int dp[n + 1][s + 1];",
    "    dp[0][0] = 1;",
    "    for (int i = 1; i <= s; i++)",
    "        dp[0][i] = 0;",
    "    for (int i = 1; i <= n; i++)",
    "    {",
    "        for (int j = 0; j <= s; j++)",
    "        {",
    "            if (w[i - 1] <= j)",
    "            {",
    "                dp[i][j] = dp[i][j - w[i - 1]] + dp[i - 1][j];",
    "            }",
    "            else",
    "            {",
    "                dp[i][j] = dp[i - 1][j];",
    "            }",
    "        }",
    "    }",
    "    cout << dp[n][s] << endl;",
    "    return 0;",
    "}",
    "",
    "//coin change 2(unbound knapsack)",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "int main()",
    "{",
    "    int n;",
    "    cin >> n;",
    "    int w[n];",
    "    for (int i = 0; i < n; i++)",
    "    {",
    "        cin >> w[i];",
    "    }",
    "    int s;",
    "    cin >> s;",
    "    int dp[n + 1][s + 1];",
    "    dp[0][0] = 0;",
    "    for (int i = 1; i <= s; i++)",
    "        dp[0][i] = INT_MAX - 1;",
    "    for (int i = 1; i <= n; i++)",
    "    {",
    "        for (int j = 0; j <= s; j++)",
    "        {",
    "            if (w[i - 1] <= j)",
    "            {",
    "                dp[i][j] = min(1 + dp[i][j - w[i - 1]], dp[i - 1][j]);",
    "            }",
    "            else",
    "            {",
    "                dp[i][j] = dp[i - 1][j];",
    "            }",
    "        }",
    "    }",
    "    // for (int i = 0; i <= n; i++)",
    "    // {",
    "    //     for (int j = 0; j <= s; j++)",
    "    //     {",
    "    //         cout << dp[i][j] << \" \";",
    "    //     }",
    "    //     cout << endl;",
    "    // }",
    "    if (dp[n][s] == INT_MAX - 1)",
    "        cout << \"Not Possible\" << endl;",
    "    else",
    "        cout << dp[n][s] << endl;",
    "    return 0;",
    "}",
    "",
    "",
    ""
  ],
  "description": ""
},
"graph": {
  "prefix": "graph",
  "body": [
    "//path_printing",
    "",
    "vector<int>v[1005];",
    "bool visit[1005];",
    "int parent[1005];",
    "void bfs(int src,int des){",
    "    queue<pair<int,int>>q;",
    "    q.push({src,0});",
    "    visit[src]=true;",
    "    while(!q.empty()){",
    "        pair<int,int> p=q.front();",
    "        q.pop();",
    "        int first=p.first;",
    "        int level=p.second;",
    "        for(auto x:v[first]){",
    "            if(!visit[x]){",
    "                q.push({x,level+1});",
    "                visit[x]=true;",
    "                parent[x]=first;",
    "            }",
    "        }",
    "    }",
    "}",
    "void solve()",
    "{",
    "    int n,e;",
    "    cin>>n>>e;",
    "    while(e--){",
    "        int a,b;",
    "        cin>>a>>b;",
    "        v[a].push_back(b);",
    "        v[b].push_back(a);",
    "    }",
    "    int src,des;",
    "    cin>>src>>des;",
    "    memset(visit,false,sizeof(visit));",
    "    memset(parent,-1,sizeof(parent));",
    "    bfs(src,des);",
    "    int x=des;",
    "    while(x!=-1){",
    "        cout<<x<<\" \";",
    "        x=parent[x];",
    "    }",
    "}",
    "",
    "//Iceland parameter",
    "",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "",
    "class Solution",
    "{",
    "public:",
    "    bool vis[105][105];",
    "    int ans;",
    "    vector<pair<int, int>> d = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};",
    "    int n, m;",
    "    bool valid(int ci, int cj)",
    "    {",
    "        if (ci >= 0 && ci < n && cj >= 0 && cj < m)",
    "            return true;",
    "        else",
    "            return false;",
    "    }",
    "    void dfs(int si, int sj, vector<vector<int>> &grid)",
    "    {",
    "        vis[si][sj] = true;",
    "        for (int i = 0; i < 4; i++)",
    "        {",
    "            int ci = si + d[i].first;",
    "            int cj = sj + d[i].second;",
    "            if (valid(ci, cj))",
    "            {",
    "                if (grid[ci][cj] == 0)",
    "                    ans++;",
    "            }",
    "            else",
    "            {",
    "                ans++;",
    "            }",
    "            if (valid(ci, cj) && !vis[ci][cj] && grid[ci][cj] == 1)",
    "            {",
    "                dfs(ci, cj, grid);",
    "            }",
    "        }",
    "    }",
    "    int islandPerimeter(vector<vector<int>> &grid)",
    "    {",
    "        memset(vis, false, sizeof(vis));",
    "        ans = 0;",
    "        n = grid.size();",
    "        m = grid[0].size();",
    "        for (int i = 0; i < n; i++)",
    "        {",
    "            for (int j = 0; j < m; j++)",
    "            {",
    "                if (!vis[i][j] && grid[i][j] == 1)  ",
    "                {",
    "                    dfs(i, j, grid);",
    "                }",
    "            }",
    "        }",
    "        return ans;",
    "    }",
    "};",
    "",
    "//find if path exist",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "",
    "class Solution",
    "{",
    "public:",
    "    vector<int> v[200005];",
    "    bool vis[200005];",
    "    void dfs(int s)",
    "    {",
    "        vis[s] = true;",
    "        for (int child : v[s])",
    "        {",
    "            if (!vis[child])",
    "            {",
    "                dfs(child);",
    "            }",
    "        }",
    "    }",
    "    bool validPath(int n, vector<vector<int>> &edges, int source, int d)",
    "    {",
    "        memset(vis, false, sizeof(vis));",
    "        for (int i = 0; i < edges.size(); i++)",
    "        {",
    "            int a = edges[i][0];",
    "            int b = edges[i][1];",
    "            v[a].push_back(b);",
    "            v[b].push_back(a);",
    "        }",
    "        dfs(source);",
    "        return vis[d];",
    "    }",
    "};",
    "",
    "//max area of iceland",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "",
    "class Solution",
    "{",
    "public:",
    "    bool vis[55][55];",
    "    int ans;",
    "    int n, m;",
    "    vector<pair<int, int>> d = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};",
    "    bool valid(int ci, int cj)",
    "    {",
    "        if (ci >= 0 && ci < n && cj >= 0 && cj < m)",
    "            return true;",
    "        else",
    "            return false;",
    "    }",
    "    void dfs(int si, int sj, vector<vector<int>> &grid)",
    "    {",
    "        vis[si][sj] = true;",
    "        ans++;",
    "        for (int i = 0; i < 4; i++)",
    "        {",
    "            int ci = si + d[i].first;",
    "            int cj = sj + d[i].second;",
    "            if (valid(ci, cj) && !vis[ci][cj] && grid[ci][cj] == 1)",
    "            {",
    "                dfs(ci, cj, grid);",
    "            }",
    "        }",
    "    }",
    "    int maxAreaOfIsland(vector<vector<int>> &grid)",
    "    {",
    "        memset(vis, false, sizeof(vis));",
    "        n = grid.size();",
    "        m = grid[0].size();",
    "        int mx = 0;",
    "        for (int i = 0; i < n; i++)",
    "        {",
    "            for (int j = 0; j < m; j++)",
    "            {",
    "                if (!vis[i][j] && grid[i][j] == 1)",
    "                {",
    "                    ans = 0;",
    "                    dfs(i, j, grid);",
    "                    mx = max(mx, ans);",
    "                }",
    "            }",
    "        }",
    "        return mx;",
    "    }",
    "};",
    "",
    "//Number of Iceland",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "",
    "class Solution",
    "{",
    "public:",
    "    int n, m;",
    "    bool vis[305][305];",
    "    vector<pair<int, int>> d = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};",
    "    bool valid(int ci, int cj)",
    "    {",
    "        if (ci >= 0 && ci < n && cj >= 0 && cj < m)",
    "            return true;",
    "        else",
    "            return false;",
    "    }",
    "    void dfs(int si, int sj, vector<vector<char>> &grid)",
    "    {",
    "        vis[si][sj] = true;",
    "        for (int i = 0; i < 4; i++)",
    "        {",
    "            int ci = si + d[i].first;",
    "            int cj = sj + d[i].second;",
    "            if (valid(ci, cj) && !vis[ci][cj] && grid[ci][cj] == '1')",
    "            {",
    "                dfs(ci, cj, grid);",
    "            }",
    "        }",
    "    }",
    "    int numIslands(vector<vector<char>> &grid)",
    "    {",
    "        n = grid.size();",
    "        m = grid[0].size();",
    "        memset(vis, false, sizeof(vis));",
    "        int ans = 0;",
    "        for (int i = 0; i < n; i++)",
    "        {",
    "            for (int j = 0; j < m; j++)",
    "            {",
    "                if (!vis[i][j] && grid[i][j] == '1')",
    "                {",
    "                    dfs(i, j, grid);",
    "                    ans++;",
    "                }",
    "            }",
    "        }",
    "        return ans;",
    "    }",
    "};",
    "",
    "//Number of close iceland",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "",
    "class Solution",
    "{",
    "public:",
    "    int n, m;",
    "    bool vis[105][105];",
    "    vector<pair<int, int>> d = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};",
    "    bool valid(int ci, int cj)",
    "    {",
    "        if (ci >= 0 && ci < n && cj >= 0 && cj < m)",
    "            return true;",
    "        else",
    "            return false;",
    "    }",
    "    bool flag;",
    "    void dfs(int si, int sj, vector<vector<int>> &grid)",
    "    {",
    "        vis[si][sj] = true;",
    "        if (si == 0 || si == n - 1 || sj == 0 || sj == m - 1)",
    "            flag = false;",
    "        for (int i = 0; i < 4; i++)",
    "        {",
    "            int ci = si + d[i].first;",
    "            int cj = sj + d[i].second;",
    "            if (valid(ci, cj) && !vis[ci][cj] && grid[ci][cj] == 0)",
    "            {",
    "                dfs(ci, cj, grid);",
    "            }",
    "        }",
    "    }",
    "    int closedIsland(vector<vector<int>> &grid)",
    "    {",
    "        memset(vis, false, sizeof(vis));",
    "        n = grid.size();",
    "        m = grid[0].size();",
    "        int ans = 0;",
    "        for (int i = 0; i < n; i++)",
    "        {",
    "            for (int j = 0; j < m; j++)",
    "            {",
    "                if (!vis[i][j] && grid[i][j] == 0)",
    "                {",
    "                    flag = true;",
    "                    dfs(i, j, grid);",
    "                    if (flag == true)",
    "                    {",
    "                        ans++;",
    "                    }",
    "                }",
    "            }",
    "        }",
    "        return ans;",
    "    }",
    "};",
    "",
    "//minimum cost for buisness(dsu)",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "const int N = 1e5 + 5;",
    "int parent[N];",
    "int group_size[N];",
    "void dsu_initialize(int n)",
    "{",
    "    for (int i = 0; i < n; i++)",
    "    {",
    "        parent[i] = -1;",
    "        group_size[i] = 1;",
    "    }",
    "}",
    "int dsu_find(int node)",
    "{",
    "    if (parent[node] == -1)",
    "        return node;",
    "    int leader = dsu_find(parent[node]);",
    "    parent[node] = leader;",
    "    return leader;",
    "}",
    "void dsu_union_by_size(int node1, int node2)",
    "{",
    "    int leaderA = dsu_find(node1);",
    "    int leaderB = dsu_find(node2);",
    "    if (group_size[leaderA] > group_size[leaderB])",
    "    {",
    "        parent[leaderB] = leaderA;",
    "        group_size[leaderA] += group_size[leaderB];",
    "    }",
    "    else",
    "    {",
    "        parent[leaderA] = leaderB;",
    "        group_size[leaderB] += group_size[leaderA];",
    "    }",
    "}",
    "class Edge",
    "{",
    "public:",
    "    int u, v, w;",
    "    Edge(int u, int v, int w)",
    "    {",
    "        this->u = u;",
    "        this->v = v;",
    "        this->w = w;",
    "    }",
    "};",
    "bool cmp(Edge a, Edge b)",
    "{",
    "    return a.w < b.w;",
    "}",
    "int main()",
    "{",
    "    int n, e;",
    "    cin >> n >> e;",
    "    dsu_initialize(n);",
    "    vector<Edge> edgeList;",
    "    while (e--)",
    "    {",
    "        int u, v, w;",
    "        cin >> u >> v >> w;",
    "        edgeList.push_back(Edge(u, v, w));",
    "    }",
    "    sort(edgeList.begin(), edgeList.end(), cmp);",
    "    int totalCost = 0;",
    "    for (Edge ed : edgeList)",
    "    {",
    "        int leaderU = dsu_find(ed.u);",
    "        int leaderV = dsu_find(ed.v);",
    "        if (leaderU == leaderV)",
    "        {",
    "            continue;",
    "        }",
    "        else",
    "        {",
    "            dsu_union_by_size(ed.u, ed.v);",
    "            totalCost += ed.w;",
    "        }",
    "    }",
    "    cout << totalCost << endl;",
    "    return 0;",
    "}",
    "",
    ""
  ],
  "description": ""
}	  ,
"maxSubarraySum": {
  "prefix": "maxSubarraySum",
  "body": [
    "int maxSubarraySum(vector<int> &arr) {",
    "    int max_sum = arr[0];",
    "    int maxi = arr[0];",
    "",
    "    for (int i = 1; i < arr.size(); i++) {",
    "        maxi = max(maxi + arr[i], arr[i]);",
    "        max_sum = max(max_sum, maxi);",
    "    }",
    "    return max_sum;",
    "}"
  ],
  "description": ""
},


"bitmanipulation": {
  "prefix": "bitmanipulation",
  "body": [
    "//string Covert2Binary",
    "string Covert2Binary(int n){",
    "    string res=\"\";",
    "    while(n!=1){",
    "        if(n%2==1)res+='1';",
    "        else res+='0';",
    "        n=n/2;",
    "    }",
    "    return res;",
    "}",
    "",
    "",
    "//Convert2Desimal",
    "int Convert2Desimal(string x){",
    "    int len=x.size();",
    "    int p2=1,num=0;",
    "    for(int i=len-1;i>=0;i--){",
    "        if(x[i]=='1'){",
    "            num+=p2;",
    "        }",
    "        p2=p2*2;",
    "    }",
    "    return num;",
    "}",
    "",
    "/* AND-> All true->true,,1 false->false",
    "    n = 13 & 7 = 5",
    "    00000...001101 - > 13",
    "    00000...000111 - > 7",
    "    -----------------------",
    "    00000...000101 - > 5",
    "",
    "    32 no. bit is a sign bit. If 32 is 0 then positive else 1 then negtive",
    "*/",
    "",
    "",
    "",
    "/* OR -> 1 true -> true",
    "    n=13|7 =15",
    "    1101",
    "    0111",
    "    ----",
    "    1111",
    "*/",
    "",
    "/* XOR -> no. of 1s ->odd -> 1",
    "   XOR -> no. of 1s ->Even ->0",
    "",
    "   n=13^7 =0",
    "   1101",
    "   0111",
    "   ----",
    "   1010",
    "",
    "*/",
    "",
    "/*",
    "    NOT n=~(5)",
    "    1. flip",
    "    2. Check (-ve)",
    "    if(condition 2 is true):",
    "        2's complement",
    "    else stop",
    "",
    "",
    "",
    "    000......00000101",
    "    111......11111010 (flip)",
    "",
    "    here sign bit 1 is (-ve)",
    "    1s = 000.....00000110",
    "                       +1",
    "    ----------------------",
    "         0000.....00000110 = 6",
    "         n = ~(5) =6",
    "",
    "",
    "",
    "    Another example:",
    "    n = ~(-6) =5 ",
    "    0.......0000110",
    "    1.......1111001 (1s)",
    "                 +1 (2s)",
    "    ----------------",
    "    1........1111010 (store negetive value in memory using 2s compliment)",
    "    0........0000101 =5 (stop)",
    "",
    "    here sign bit (+ve)->stop                   ",
    "*/",
    "/*",
    "    >> Right shift",
    "",
    "    m=13>>1 =6",
    "    1101",
    "    0110",
    "",
    "    m=13>>2",
    "    1101",
    "    0011",
    "",
    "    n>>k = (n/n^k)",
    "*/",
    "/*",
    "    << Left shift",
    "    n =13<<1 =26",
    "    01101",
    "    11010",
    "",
    "    mum<<k=n*2^k",
    "*/",
    "/*",
    "    1<<13 =2^23",
    "    1<<n = 2^n",
    "*/",
    "/*",
    "    pb1: check if the ith bit is set or not",
    "    ans: if(n&(1<<i)!=0)",
    "",
    "    pb2: Set the ith bit",
    "    ans: n|1<<i",
    "",
    "    pb3: Clear the ith bit",
    "    ans: n&~(1<<i)",
    "",
    "    pb4: Toggle the ith bit",
    "    ans: n^(1<<i)",
    "",
    "    pb5: Remove the rightmost bit",
    "    ans: n&n-1",
    "    ",
    "    pb6: Check the number is a power of 2",
    "    ans: if(n&n-1 ==0)",
    "",
    "    pb7: Count the number of set bit",
    "    ans:",
    "    int countSetBits(int n)",
    "    {",
    "        int count = 0;",
    "        while (n)",
    "        {",
    "            n = n & (n - 1);",
    "            count++;",
    "        }",
    "        return count;",
    "    }",
    "",
    "    pb8: Minimum bit flib to convert number",
    "    ans:",
    "    start=10 , Goal=7",
    "    start^Goal",
    "    1010",
    "   ^0110",
    "   ------",
    "    1101",
    "    Then ccount number of set bit to following pb7",
    "*/",
    "/*",
    "has_single_bit: checks if the number is a power of two",
    "bit_ceil / bit_floor: round up/down to the next power of two",
    "rotl / rotr: rotate the bits in the number",
    "countl_zero / countr_zero / countl_one / countr_one: count the leading/trailing zeros/ones",
    "popcount: count the number of set bits",
    "Additionally, there are also predefined functions in some compilers that help working with bits. E.g. GCC defines a list at Built-in Functions Provided by GCC that also work in older versions of C++:",
    "",
    "__builtin_popcount(unsigned int) returns the number of set bits (__builtin_popcount(0b0001'0010'1100) == 4)",
    "__builtin_ffs(int) finds the index of the first (most right) set bit (__builtin_ffs(0b0001'0010'1100) == 3)",
    "__builtin_clz(unsigned int) the count of leading zeros (__builtin_clz(0b0001'0010'1100) == 23)",
    "__builtin_ctz(unsigned int) the count of trailing zeros (__builtin_ctz(0b0001'0010'1100) == 2)",
    "__builtin_parity(x) the parity (even or odd) of the number of ones in the bit representation",
    "*/",
    ""
  ],
  "description": ""
},
"recursion": {
  "prefix": "recursion",
  "body": [
    "//Subarray with Sum k",
    "",
    "#include <iostream>",
    "#include <vector>",
    "using namespace std;",
    "",
    "void findSubarray(vector<int>& arr, int k, int i, vector<int>& sub, int sum) {",
    "    if (sum == k) {",
    "        for (int x : sub) cout << x << \" \";",
    "        cout << endl;",
    "        return;",
    "    }",
    "    if (i == arr.size() || sum > k) return;",
    "    sub.push_back(arr[i]);",
    "    findSubarray(arr, k, i + 1, sub, sum + arr[i]);",
    "    sub.pop_back();",
    "    findSubarray(arr, k, i + 1, sub, sum);",
    "}",
    "",
    "int main() {",
    "    vector<int> arr = {1, 2, 3};",
    "    int k = 5;",
    "    vector<int> sub;",
    "    findSubarray(arr, k, 0, sub, 0);",
    "    return 0;",
    "}",
    "",
    "//Combination Sum (1 number can be used unlimited times)",
    "#include <iostream>",
    "#include <vector>",
    "using namespace std;",
    "",
    "void combinationSum(vector<int>& arr, int k, int i, vector<int>& comb, int sum) {",
    "    if (sum == k) {",
    "        for (int x : comb) cout << x << \" \";",
    "        cout << endl;",
    "        return;",
    "    }",
    "    if (i == arr.size() || sum > k) return;",
    "    comb.push_back(arr[i]);",
    "    combinationSum(arr, k, i, comb, sum + arr[i]);",
    "    comb.pop_back();",
    "    combinationSum(arr, k, i + 1, comb, sum);",
    "}",
    "",
    "int main() {",
    "    vector<int> arr = {2, 3, 6, 7};",
    "    int k = 7;",
    "    vector<int> comb;",
    "    combinationSum(arr, k, 0, comb, 0);",
    "    return 0;",
    "}",
    "",
    "3. Print All Permutations",
    "#include <iostream>",
    "#include <vector>",
    "#include <algorithm>",
    "using namespace std;",
    "",
    "void permutations(vector<int>& arr, int l, int r) {",
    "    if (l == r) {",
    "        for (int x : arr) cout << x << \" \";",
    "        cout << endl;",
    "        return;",
    "    }",
    "    for (int i = l; i <= r; ++i) {",
    "        swap(arr[l], arr[i]);",
    "        permutations(arr, l + 1, r);",
    "        swap(arr[l], arr[i]);",
    "    }",
    "}",
    "",
    "int main() {",
    "    vector<int> arr = {1, 2, 3};",
    "    permutations(arr, 0, arr.size() - 1);",
    "    return 0;",
    "}",
    "",
    ""
  ],
  "description": ""
},
"GenPow": {
  "prefix": "GenPow",
  "body": [
    "int GenPow(int a, int b) {",
    "    int result = 1;",
    "    while (b > 0) {",
    "        if (b & 1) result *= a;",
    "        a *= a;",
    "        b >>= 1;",
    "    }",
    "    return result;",
    "}",
    ""
  ],
  "description": ""
}

}
